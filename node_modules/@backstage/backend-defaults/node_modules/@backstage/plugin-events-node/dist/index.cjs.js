'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');

class EventRouter {
  events;
  topics;
  subscribed = false;
  constructor(options) {
    this.events = options.events;
    this.topics = options.topics;
  }
  /**
   * Subscribes itself to the topic(s),
   * after which events potentially can be received
   * and processed by {@link EventRouter.onEvent}.
   */
  async subscribe() {
    if (this.subscribed) {
      return;
    }
    this.subscribed = true;
    await this.events.subscribe({
      id: this.getSubscriberId(),
      topics: this.topics,
      onEvent: this.onEvent.bind(this)
    });
  }
  async onEvent(params) {
    const topic = this.determineDestinationTopic(params);
    if (!topic) {
      return;
    }
    await this.events.publish({
      ...params,
      topic
    });
  }
}

class DefaultEventsService {
  constructor(logger) {
    this.logger = logger;
  }
  subscribers = /* @__PURE__ */ new Map();
  static create(options) {
    return new DefaultEventsService(options.logger);
  }
  /**
   * Returns a plugin-scoped context of the `EventService`
   * that ensures to prefix subscriber IDs with the plugin ID.
   *
   * @param pluginId - The plugin that the `EventService` should be created for.
   */
  forPlugin(pluginId) {
    return {
      publish: (params) => {
        return this.publish(params);
      },
      subscribe: (options) => {
        return this.subscribe({
          ...options,
          id: `${pluginId}.${options.id}`
        });
      }
    };
  }
  async publish(params) {
    this.logger.debug(
      `Event received: topic=${params.topic}, metadata=${JSON.stringify(
        params.metadata
      )}, payload=${JSON.stringify(params.eventPayload)}`
    );
    if (!this.subscribers.has(params.topic)) {
      return;
    }
    const onEventPromises = [];
    this.subscribers.get(params.topic)?.forEach((subscription) => {
      onEventPromises.push(
        (async () => {
          try {
            await subscription.onEvent(params);
          } catch (error) {
            this.logger.warn(
              `Subscriber "${subscription.id}" failed to process event for topic "${params.topic}"`,
              error
            );
          }
        })()
      );
    });
    await Promise.all(onEventPromises);
  }
  async subscribe(options) {
    options.topics.forEach((topic) => {
      if (!this.subscribers.has(topic)) {
        this.subscribers.set(topic, []);
      }
      this.subscribers.get(topic).push({
        id: options.id,
        onEvent: options.onEvent
      });
    });
  }
}

class SubTopicEventRouter extends EventRouter {
  constructor(options) {
    super({
      events: options.events,
      topics: [options.topic]
    });
  }
  determineDestinationTopic(params) {
    const subTopic = this.determineSubTopic(params);
    return subTopic ? `${params.topic}.${subTopic}` : void 0;
  }
}

const eventsServiceRef = backendPluginApi.createServiceRef({
  id: "events.service",
  scope: "plugin"
});
const eventsServiceFactory = backendPluginApi.createServiceFactory({
  service: eventsServiceRef,
  deps: {
    pluginMetadata: backendPluginApi.coreServices.pluginMetadata,
    rootLogger: backendPluginApi.coreServices.rootLogger
  },
  async createRootContext({ rootLogger }) {
    return DefaultEventsService.create({ logger: rootLogger });
  },
  async factory({ pluginMetadata }, eventsService) {
    return eventsService.forPlugin(pluginMetadata.getId());
  }
});

exports.DefaultEventsService = DefaultEventsService;
exports.EventRouter = EventRouter;
exports.SubTopicEventRouter = SubTopicEventRouter;
exports.eventsServiceFactory = eventsServiceFactory;
exports.eventsServiceRef = eventsServiceRef;
//# sourceMappingURL=index.cjs.js.map
