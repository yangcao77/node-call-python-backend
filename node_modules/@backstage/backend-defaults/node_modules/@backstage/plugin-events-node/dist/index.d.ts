import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { LoggerService } from '@backstage/backend-plugin-api';

/**
 * @public
 */
interface EventParams<TPayload = unknown> {
    /**
     * Topic for which this event should be published.
     */
    topic: string;
    /**
     * Event payload.
     */
    eventPayload: TPayload;
    /**
     * Metadata (e.g., HTTP headers and similar for events received from external).
     */
    metadata?: Record<string, string | string[] | undefined>;
}

/**
 * Allows a decoupled and asynchronous communication between components.
 * Components can publish events for a given topic and
 * others can subscribe for future events for topics they are interested in.
 *
 * @public
 */
interface EventsService {
    /**
     * Publishes an event for the topic.
     *
     * @param params - parameters for the to be published event.
     */
    publish(params: EventParams): Promise<void>;
    /**
     * Subscribes to one or more topics, registering an event handler for them.
     *
     * @param options - event subscription options.
     */
    subscribe(options: EventsServiceSubscribeOptions): Promise<void>;
}
/**
 * @public
 */
type EventsServiceSubscribeOptions = {
    /**
     * Identifier for the subscription. E.g., used as part of log messages.
     */
    id: string;
    topics: string[];
    onEvent: EventsServiceEventHandler;
};
/**
 * @public
 */
type EventsServiceEventHandler = (params: EventParams) => Promise<void>;

/**
 * Subscribes to a topic and - depending on a set of conditions -
 * republishes the event to another topic.
 *
 * @see {@link https://www.enterpriseintegrationpatterns.com/MessageRouter.html | Message Router pattern}.
 * @public
 */
declare abstract class EventRouter {
    private readonly events;
    private readonly topics;
    private subscribed;
    protected constructor(options: {
        events: EventsService;
        topics: string[];
    });
    protected abstract getSubscriberId(): string;
    protected abstract determineDestinationTopic(params: EventParams): string | undefined;
    /**
     * Subscribes itself to the topic(s),
     * after which events potentially can be received
     * and processed by {@link EventRouter.onEvent}.
     */
    subscribe(): Promise<void>;
    onEvent(params: EventParams): Promise<void>;
}

/**
 * In-process event broker which will pass the event to all registered subscribers
 * interested in it.
 * Events will not be persisted in any form.
 * Events will not be passed to subscribers at other instances of the same cluster.
 *
 * @public
 */
declare class DefaultEventsService implements EventsService {
    private readonly logger;
    private readonly subscribers;
    private constructor();
    static create(options: {
        logger: LoggerService;
    }): DefaultEventsService;
    /**
     * Returns a plugin-scoped context of the `EventService`
     * that ensures to prefix subscriber IDs with the plugin ID.
     *
     * @param pluginId - The plugin that the `EventService` should be created for.
     */
    forPlugin(pluginId: string): EventsService;
    publish(params: EventParams): Promise<void>;
    subscribe(options: EventsServiceSubscribeOptions): Promise<void>;
}

/**
 * @public
 */
interface RequestDetails {
    /**
     * Request body. JSON payloads have been parsed already.
     */
    body: unknown;
    /**
     * Key-value pairs of header names and values. Header names are lower-cased.
     */
    headers: Record<string, string | string[] | undefined>;
}

/**
 * Details for how to respond to the rejection
 * of the received HTTP request transmitting an event payload.
 *
 * @public
 */
interface RequestRejectionDetails {
    status: number;
    payload: unknown;
}

/**
 * Passed context for the validation
 * at which rejections can be expressed.
 *
 * @public
 */
interface RequestValidationContext {
    /**
     * Rejects the validated request
     *
     * @param details - Optional details about the rejection which will be provided to the sender.
     */
    reject(details?: Partial<RequestRejectionDetails>): void;
}

/**
 * Validator used to check the received HTTP request
 * transmitting an event payload.
 *
 * E.g., it can be used for signature verification like
 * for GitHub webhook events
 * (https://docs.github.com/en/developers/webhooks-and-events/webhooks/creating-webhooks#secret)
 * or other kinds of checks.
 *
 * @public
 */
type RequestValidator = (request: RequestDetails, context: RequestValidationContext) => Promise<void>;

/**
 * @public
 */
interface HttpPostIngressOptions {
    topic: string;
    validator?: RequestValidator;
}

/**
 * Subscribes to the provided (generic) topic
 * and publishes the events under the more concrete sub-topic
 * depending on the implemented logic for determining it.
 * Implementing classes might use information from `metadata`
 * and/or properties within the payload.
 *
 * @public
 */
declare abstract class SubTopicEventRouter extends EventRouter {
    protected constructor(options: {
        events: EventsService;
        topic: string;
    });
    protected abstract determineSubTopic(params: EventParams): string | undefined;
    protected determineDestinationTopic(params: EventParams): string | undefined;
}

/**
 * Handles received events.
 * This may include triggering refreshes of catalog entities
 * or other actions to react on events.
 *
 * @public
 * @deprecated use the `EventsService` via the constructor, setter, or other means instead
 */
interface EventSubscriber {
    /**
     * Supported event topics like "github", "bitbucketCloud", etc.
     *
     * @deprecated use the `EventsService` via the constructor, setter, or other means instead
     */
    supportsEventTopics(): string[];
    /**
     * React on a received event.
     *
     * @param params - parameters for the to be received event.
     * @deprecated you are not required to expose this anymore when using `EventsService`
     */
    onEvent(params: EventParams): Promise<void>;
}

/**
 * Allows a decoupled and asynchronous communication between components.
 * Components can publish events for a given topic and
 * others can subscribe for future events for topics they are interested in.
 *
 * @public
 * @deprecated use `EventsService` instead
 */
interface EventBroker {
    /**
     * Publishes an event for the topic.
     *
     * @param params - parameters for the to be published event.
     */
    publish(params: EventParams): Promise<void>;
    /**
     * Adds new subscribers for {@link EventSubscriber#supportsEventTopics | interested topics}.
     *
     * @param subscribers - interested in events of specified topics.
     */
    subscribe(...subscribers: Array<EventSubscriber | Array<EventSubscriber>>): void;
}

/**
 * Publishes events to be consumed by subscribers for their topic.
 * The events can come from different (external) sources
 * like emitted themselves, received via HTTP endpoint (i.e. webhook)
 * or from event brokers, queues, etc.
 *
 * @public
 * @deprecated use the `EventsService` via the constructor, setter, or other means instead
 */
interface EventPublisher {
    /**
     * @deprecated use the `EventsService` via the constructor, setter, or other means instead
     */
    setEventBroker(eventBroker: EventBroker): Promise<void>;
}

/**
 * The {@link EventsService} that allows to publish events, and subscribe to topics.
 * Uses the `root` scope so that events can be shared across all plugins, modules, and more.
 *
 * @public
 */
declare const eventsServiceRef: _backstage_backend_plugin_api.ServiceRef<EventsService, "plugin", "singleton">;
/** @public */
declare const eventsServiceFactory: _backstage_backend_plugin_api.ServiceFactory<EventsService, "plugin", "singleton">;

export { DefaultEventsService, type EventBroker, type EventParams, type EventPublisher, EventRouter, type EventSubscriber, type EventsService, type EventsServiceEventHandler, type EventsServiceSubscribeOptions, type HttpPostIngressOptions, type RequestDetails, type RequestRejectionDetails, type RequestValidationContext, type RequestValidator, SubTopicEventRouter, eventsServiceFactory, eventsServiceRef };
