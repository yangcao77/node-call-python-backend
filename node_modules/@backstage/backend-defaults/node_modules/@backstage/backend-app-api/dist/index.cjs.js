'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var alpha = require('@backstage/backend-plugin-api/alpha');

class Node {
  constructor(value, consumes, provides) {
    this.value = value;
    this.consumes = consumes;
    this.provides = provides;
  }
  static from(input) {
    return new Node(
      input.value,
      input.consumes ? new Set(input.consumes) : /* @__PURE__ */ new Set(),
      input.provides ? new Set(input.provides) : /* @__PURE__ */ new Set()
    );
  }
}
class CycleKeySet {
  static from(nodes) {
    return new CycleKeySet(nodes);
  }
  #nodeIds;
  #cycleKeys;
  constructor(nodes) {
    this.#nodeIds = new Map(nodes.map((n, i) => [n.value, i]));
    this.#cycleKeys = /* @__PURE__ */ new Set();
  }
  tryAdd(path) {
    const cycleKey = this.#getCycleKey(path);
    if (this.#cycleKeys.has(cycleKey)) {
      return false;
    }
    this.#cycleKeys.add(cycleKey);
    return true;
  }
  #getCycleKey(path) {
    return path.map((n) => this.#nodeIds.get(n)).sort().join(",");
  }
}
class DependencyGraph {
  static fromMap(nodes) {
    return this.fromIterable(
      Object.entries(nodes).map(([key, node]) => ({
        value: String(key),
        ...node
      }))
    );
  }
  static fromIterable(nodeInputs) {
    const nodes = new Array();
    for (const nodeInput of nodeInputs) {
      nodes.push(Node.from(nodeInput));
    }
    return new DependencyGraph(nodes);
  }
  #nodes;
  #allProvided;
  constructor(nodes) {
    this.#nodes = nodes;
    this.#allProvided = /* @__PURE__ */ new Set();
    for (const node of this.#nodes.values()) {
      for (const produced of node.provides) {
        this.#allProvided.add(produced);
      }
    }
  }
  /**
   * Find all nodes that consume dependencies that are not provided by any other node.
   */
  findUnsatisfiedDeps() {
    const unsatisfiedDependencies = [];
    for (const node of this.#nodes.values()) {
      const unsatisfied = Array.from(node.consumes).filter(
        (id) => !this.#allProvided.has(id)
      );
      if (unsatisfied.length > 0) {
        unsatisfiedDependencies.push({ value: node.value, unsatisfied });
      }
    }
    return unsatisfiedDependencies;
  }
  /**
   * Detect the first circular dependency within the graph, returning the path of nodes that
   * form a cycle, with the same node as the first and last element of the array.
   */
  detectCircularDependency() {
    return this.detectCircularDependencies().next().value;
  }
  /**
   * Detect circular dependencies within the graph, returning the path of nodes that
   * form a cycle, with the same node as the first and last element of the array.
   */
  *detectCircularDependencies() {
    const cycleKeys = CycleKeySet.from(this.#nodes);
    for (const startNode of this.#nodes) {
      const visited = /* @__PURE__ */ new Set();
      const stack = new Array([
        startNode,
        [startNode.value]
      ]);
      while (stack.length > 0) {
        const [node, path] = stack.pop();
        if (visited.has(node)) {
          continue;
        }
        visited.add(node);
        for (const consumed of node.consumes) {
          const providerNodes = this.#nodes.filter(
            (other) => other.provides.has(consumed)
          );
          for (const provider of providerNodes) {
            if (provider === startNode) {
              if (cycleKeys.tryAdd(path)) {
                yield [...path, startNode.value];
              }
              break;
            }
            if (!visited.has(provider)) {
              stack.push([provider, [...path, provider.value]]);
            }
          }
        }
      }
    }
    return void 0;
  }
  /**
   * Traverses the dependency graph in topological order, calling the provided
   * function for each node and waiting for it to resolve.
   *
   * The nodes are traversed in parallel, but in such a way that no node is
   * visited before all of its dependencies.
   *
   * Dependencies of nodes that are not produced by any other nodes will be ignored.
   */
  async parallelTopologicalTraversal(fn) {
    const allProvided = this.#allProvided;
    const producedSoFar = /* @__PURE__ */ new Set();
    const waiting = new Set(this.#nodes.values());
    const visited = /* @__PURE__ */ new Set();
    const results = new Array();
    let inFlight = 0;
    async function processMoreNodes() {
      if (waiting.size === 0) {
        return;
      }
      const nodesToProcess = [];
      for (const node of waiting) {
        let ready = true;
        for (const consumed of node.consumes) {
          if (allProvided.has(consumed) && !producedSoFar.has(consumed)) {
            ready = false;
            continue;
          }
        }
        if (ready) {
          nodesToProcess.push(node);
        }
      }
      for (const node of nodesToProcess) {
        waiting.delete(node);
      }
      if (nodesToProcess.length === 0 && inFlight === 0) {
        throw new Error("Circular dependency detected");
      }
      await Promise.all(nodesToProcess.map(processNode));
    }
    async function processNode(node) {
      visited.add(node);
      inFlight += 1;
      const result = await fn(node.value);
      results.push(result);
      node.provides.forEach((produced) => producedSoFar.add(produced));
      inFlight -= 1;
      await processMoreNodes();
    }
    await processMoreNodes();
    return results;
  }
}

function toInternalServiceFactory(factory) {
  const f = factory;
  if (f.$$type !== "@backstage/BackendFeature") {
    throw new Error(`Invalid service factory, bad type '${f.$$type}'`);
  }
  if (f.version !== "v1") {
    throw new Error(`Invalid service factory, bad version '${f.version}'`);
  }
  return f;
}
function createPluginMetadataServiceFactory(pluginId) {
  return backendPluginApi.createServiceFactory({
    service: backendPluginApi.coreServices.pluginMetadata,
    deps: {},
    factory: async () => ({ getId: () => pluginId })
  });
}
class ServiceRegistry {
  static create(factories) {
    const factoryMap = /* @__PURE__ */ new Map();
    for (const factory of factories) {
      if (factory.service.multiton) {
        const existing = factoryMap.get(factory.service.id) ?? [];
        factoryMap.set(
          factory.service.id,
          existing.concat(toInternalServiceFactory(factory))
        );
      } else {
        factoryMap.set(factory.service.id, [toInternalServiceFactory(factory)]);
      }
    }
    const registry = new ServiceRegistry(factoryMap);
    registry.checkForCircularDeps();
    return registry;
  }
  #providedFactories;
  #loadedDefaultFactories;
  #implementations;
  #rootServiceImplementations = /* @__PURE__ */ new Map();
  #addedFactoryIds = /* @__PURE__ */ new Set();
  #instantiatedFactories = /* @__PURE__ */ new Set();
  constructor(factories) {
    this.#providedFactories = factories;
    this.#loadedDefaultFactories = /* @__PURE__ */ new Map();
    this.#implementations = /* @__PURE__ */ new Map();
  }
  #resolveFactory(ref, pluginId) {
    if (ref.id === backendPluginApi.coreServices.pluginMetadata.id) {
      return Promise.resolve([
        toInternalServiceFactory(createPluginMetadataServiceFactory(pluginId))
      ]);
    }
    let resolvedFactory = this.#providedFactories.get(ref.id);
    const { __defaultFactory: defaultFactory } = ref;
    if (!resolvedFactory && !defaultFactory) {
      return void 0;
    }
    if (!resolvedFactory) {
      let loadedFactory = this.#loadedDefaultFactories.get(defaultFactory);
      if (!loadedFactory) {
        loadedFactory = Promise.resolve().then(() => defaultFactory(ref)).then(
          (f) => toInternalServiceFactory(typeof f === "function" ? f() : f)
        );
        this.#loadedDefaultFactories.set(defaultFactory, loadedFactory);
      }
      resolvedFactory = loadedFactory.then(
        (factory) => [factory],
        (error) => {
          throw new Error(
            `Failed to instantiate service '${ref.id}' because the default factory loader threw an error, ${errors.stringifyError(
              error
            )}`
          );
        }
      );
    }
    return Promise.resolve(resolvedFactory);
  }
  #checkForMissingDeps(factory, pluginId) {
    const missingDeps = Object.values(factory.deps).filter((ref) => {
      if (ref.id === backendPluginApi.coreServices.pluginMetadata.id) {
        return false;
      }
      if (this.#providedFactories.get(ref.id)) {
        return false;
      }
      if (ref.multiton) {
        return false;
      }
      return !ref.__defaultFactory;
    });
    if (missingDeps.length) {
      const missing = missingDeps.map((r) => `'${r.id}'`).join(", ");
      throw new Error(
        `Failed to instantiate service '${factory.service.id}' for '${pluginId}' because the following dependent services are missing: ${missing}`
      );
    }
  }
  checkForCircularDeps() {
    const graph = DependencyGraph.fromIterable(
      Array.from(this.#providedFactories).map(([serviceId, factories]) => ({
        value: serviceId,
        provides: [serviceId],
        consumes: factories.flatMap(
          (factory) => Object.values(factory.deps).map((d) => d.id)
        )
      }))
    );
    const circularDependencies = Array.from(graph.detectCircularDependencies());
    if (circularDependencies.length) {
      const cycles = circularDependencies.map((c) => c.map((id) => `'${id}'`).join(" -> ")).join("\n  ");
      throw new errors.ConflictError(`Circular dependencies detected:
  ${cycles}`);
    }
  }
  add(factory) {
    const factoryId = factory.service.id;
    if (factoryId === backendPluginApi.coreServices.pluginMetadata.id) {
      throw new Error(
        `The ${backendPluginApi.coreServices.pluginMetadata.id} service cannot be overridden`
      );
    }
    if (this.#instantiatedFactories.has(factoryId)) {
      throw new Error(
        `Unable to set service factory with id ${factoryId}, service has already been instantiated`
      );
    }
    if (factory.service.multiton) {
      const newFactories = (this.#providedFactories.get(factoryId) ?? []).concat(toInternalServiceFactory(factory));
      this.#providedFactories.set(factoryId, newFactories);
    } else {
      if (this.#addedFactoryIds.has(factoryId)) {
        throw new Error(
          `Duplicate service implementations provided for ${factoryId}`
        );
      }
      this.#addedFactoryIds.add(factoryId);
      this.#providedFactories.set(factoryId, [
        toInternalServiceFactory(factory)
      ]);
    }
  }
  async initializeEagerServicesWithScope(scope, pluginId = "root") {
    for (const [factory] of this.#providedFactories.values()) {
      if (factory.service.scope === scope) {
        if (scope === "root" && factory.initialization !== "lazy") {
          await this.get(factory.service, pluginId);
        } else if (scope === "plugin" && factory.initialization === "always") {
          await this.get(factory.service, pluginId);
        }
      }
    }
  }
  get(ref, pluginId) {
    this.#instantiatedFactories.add(ref.id);
    const resolvedFactory = this.#resolveFactory(ref, pluginId);
    if (!resolvedFactory) {
      return ref.multiton ? Promise.resolve([]) : void 0;
    }
    return resolvedFactory.then((factories) => {
      return Promise.all(
        factories.map((factory) => {
          if (factory.service.scope === "root") {
            let existing = this.#rootServiceImplementations.get(factory);
            if (!existing) {
              this.#checkForMissingDeps(factory, pluginId);
              const rootDeps = new Array();
              for (const [name, serviceRef] of Object.entries(factory.deps)) {
                if (serviceRef.scope !== "root") {
                  throw new Error(
                    `Failed to instantiate 'root' scoped service '${ref.id}' because it depends on '${serviceRef.scope}' scoped service '${serviceRef.id}'.`
                  );
                }
                const target = this.get(serviceRef, pluginId);
                rootDeps.push(target.then((impl) => [name, impl]));
              }
              existing = Promise.all(rootDeps).then(
                (entries) => factory.factory(Object.fromEntries(entries), void 0)
              );
              this.#rootServiceImplementations.set(factory, existing);
            }
            return existing;
          }
          let implementation = this.#implementations.get(factory);
          if (!implementation) {
            this.#checkForMissingDeps(factory, pluginId);
            const rootDeps = new Array();
            for (const [name, serviceRef] of Object.entries(factory.deps)) {
              if (serviceRef.scope === "root") {
                const target = this.get(serviceRef, pluginId);
                rootDeps.push(target.then((impl) => [name, impl]));
              }
            }
            implementation = {
              context: Promise.all(rootDeps).then(
                (entries) => factory.createRootContext?.(Object.fromEntries(entries))
              ).catch((error) => {
                const cause = errors.stringifyError(error);
                throw new Error(
                  `Failed to instantiate service '${ref.id}' because createRootContext threw an error, ${cause}`
                );
              }),
              byPlugin: /* @__PURE__ */ new Map()
            };
            this.#implementations.set(factory, implementation);
          }
          let result = implementation.byPlugin.get(pluginId);
          if (!result) {
            const allDeps = new Array();
            for (const [name, serviceRef] of Object.entries(factory.deps)) {
              const target = this.get(serviceRef, pluginId);
              allDeps.push(target.then((impl) => [name, impl]));
            }
            result = implementation.context.then(
              (context) => Promise.all(allDeps).then(
                (entries) => factory.factory(Object.fromEntries(entries), context)
              )
            ).catch((error) => {
              const cause = errors.stringifyError(error);
              throw new Error(
                `Failed to instantiate service '${ref.id}' for '${pluginId}' because the factory function threw an error, ${cause}`
              );
            });
            implementation.byPlugin.set(pluginId, result);
          }
          return result;
        })
      );
    }).then((results) => ref.multiton ? results : results[0]);
  }
}

const LOGGER_INTERVAL_MAX = 6e4;
function joinIds(ids) {
  return [...ids].map((id) => `'${id}'`).join(", ");
}
function createInitializationLogger(pluginIds, rootLogger) {
  const logger = rootLogger?.child({ type: "initialization" });
  const starting = new Set(pluginIds);
  const started = /* @__PURE__ */ new Set();
  logger?.info(`Plugin initialization started: ${joinIds(pluginIds)}`);
  const getInitStatus = () => {
    let status = "";
    if (started.size > 0) {
      status = `, newly initialized: ${joinIds(started)}`;
      started.clear();
    }
    if (starting.size > 0) {
      status += `, still initializing: ${joinIds(starting)}`;
    }
    return status;
  };
  let interval = 1e3;
  let prevInterval = 0;
  let timeout;
  const onTimeout = () => {
    logger?.info(`Plugin initialization in progress${getInitStatus()}`);
    const nextInterval = Math.min(interval + prevInterval, LOGGER_INTERVAL_MAX);
    prevInterval = interval;
    interval = nextInterval;
    timeout = setTimeout(onTimeout, nextInterval);
  };
  timeout = setTimeout(onTimeout, interval);
  return {
    onPluginStarted(pluginId) {
      starting.delete(pluginId);
      started.add(pluginId);
    },
    onAllStarted() {
      logger?.info(`Plugin initialization complete${getInitStatus()}`);
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
    }
  };
}

function unwrapFeature(feature) {
  if ("$$type" in feature) {
    return feature;
  }
  if ("default" in feature) {
    return feature.default;
  }
  return feature;
}

const instanceRegistry = new class InstanceRegistry {
  #registered = false;
  #instances = /* @__PURE__ */ new Set();
  register(instance) {
    if (!this.#registered) {
      this.#registered = true;
      process.addListener("SIGTERM", this.#exitHandler);
      process.addListener("SIGINT", this.#exitHandler);
      process.addListener("beforeExit", this.#exitHandler);
    }
    this.#instances.add(instance);
  }
  unregister(instance) {
    this.#instances.delete(instance);
  }
  #exitHandler = async () => {
    try {
      const results = await Promise.allSettled(
        Array.from(this.#instances).map((b) => b.stop())
      );
      const errors = results.flatMap(
        (r) => r.status === "rejected" ? [r.reason] : []
      );
      if (errors.length > 0) {
        for (const error of errors) {
          console.error(error);
        }
        process.exit(1);
      } else {
        process.exit(0);
      }
    } catch (error) {
      console.error(error);
      process.exit(1);
    }
  };
}();
class BackendInitializer {
  #startPromise;
  #stopPromise;
  #registrations = new Array();
  #extensionPoints = /* @__PURE__ */ new Map();
  #serviceRegistry;
  #registeredFeatures = new Array();
  #registeredFeatureLoaders = new Array();
  constructor(defaultApiFactories) {
    this.#serviceRegistry = ServiceRegistry.create([...defaultApiFactories]);
  }
  async #getInitDeps(deps, pluginId, moduleId) {
    const result = /* @__PURE__ */ new Map();
    const missingRefs = /* @__PURE__ */ new Set();
    for (const [name, ref] of Object.entries(deps)) {
      const ep = this.#extensionPoints.get(ref.id);
      if (ep) {
        if (ep.pluginId !== pluginId) {
          throw new Error(
            `Illegal dependency: Module '${moduleId}' for plugin '${pluginId}' attempted to depend on extension point '${ref.id}' for plugin '${ep.pluginId}'. Extension points can only be used within their plugin's scope.`
          );
        }
        result.set(name, ep.impl);
      } else {
        const impl = await this.#serviceRegistry.get(
          ref,
          pluginId
        );
        if (impl) {
          result.set(name, impl);
        } else {
          missingRefs.add(ref);
        }
      }
    }
    if (missingRefs.size > 0) {
      const missing = Array.from(missingRefs).join(", ");
      const target = moduleId ? `module '${moduleId}' for plugin '${pluginId}'` : `plugin '${pluginId}'`;
      throw new Error(
        `Service or extension point dependencies of ${target} are missing for the following ref(s): ${missing}`
      );
    }
    return Object.fromEntries(result);
  }
  add(feature) {
    if (this.#startPromise) {
      throw new Error("feature can not be added after the backend has started");
    }
    this.#registeredFeatures.push(Promise.resolve(feature));
  }
  #addFeature(feature) {
    if (isServiceFactory(feature)) {
      this.#serviceRegistry.add(feature);
    } else if (isBackendFeatureLoader(feature)) {
      this.#registeredFeatureLoaders.push(feature);
    } else if (isBackendRegistrations(feature)) {
      this.#registrations.push(feature);
    } else {
      throw new Error(
        `Failed to add feature, invalid feature ${JSON.stringify(feature)}`
      );
    }
  }
  async start() {
    if (this.#startPromise) {
      throw new Error("Backend has already started");
    }
    if (this.#stopPromise) {
      throw new Error("Backend has already stopped");
    }
    instanceRegistry.register(this);
    this.#startPromise = this.#doStart();
    await this.#startPromise;
  }
  async #doStart() {
    this.#serviceRegistry.checkForCircularDeps();
    for (const feature of this.#registeredFeatures) {
      this.#addFeature(await feature);
    }
    const featureDiscovery = await this.#serviceRegistry.get(
      // TODO: Let's leave this in place and remove it once the deprecated service is removed. We can do that post-1.0 since it's alpha
      alpha.featureDiscoveryServiceRef,
      "root"
    );
    if (featureDiscovery) {
      const { features } = await featureDiscovery.getBackendFeatures();
      for (const feature of features) {
        this.#addFeature(unwrapFeature(feature));
      }
      this.#serviceRegistry.checkForCircularDeps();
    }
    await this.#applyBackendFeatureLoaders(this.#registeredFeatureLoaders);
    await this.#serviceRegistry.initializeEagerServicesWithScope("root");
    const pluginInits = /* @__PURE__ */ new Map();
    const moduleInits = /* @__PURE__ */ new Map();
    for (const feature of this.#registrations) {
      for (const r of feature.getRegistrations()) {
        const provides = /* @__PURE__ */ new Set();
        if (r.type === "plugin" || r.type === "module") {
          for (const [extRef, extImpl] of r.extensionPoints) {
            if (this.#extensionPoints.has(extRef.id)) {
              throw new Error(
                `ExtensionPoint with ID '${extRef.id}' is already registered`
              );
            }
            this.#extensionPoints.set(extRef.id, {
              impl: extImpl,
              pluginId: r.pluginId
            });
            provides.add(extRef);
          }
        }
        if (r.type === "plugin") {
          if (pluginInits.has(r.pluginId)) {
            throw new Error(`Plugin '${r.pluginId}' is already registered`);
          }
          pluginInits.set(r.pluginId, {
            provides,
            consumes: new Set(Object.values(r.init.deps)),
            init: r.init
          });
        } else if (r.type === "module") {
          let modules = moduleInits.get(r.pluginId);
          if (!modules) {
            modules = /* @__PURE__ */ new Map();
            moduleInits.set(r.pluginId, modules);
          }
          if (modules.has(r.moduleId)) {
            throw new Error(
              `Module '${r.moduleId}' for plugin '${r.pluginId}' is already registered`
            );
          }
          modules.set(r.moduleId, {
            provides,
            consumes: new Set(Object.values(r.init.deps)),
            init: r.init
          });
        } else {
          throw new Error(`Invalid registration type '${r.type}'`);
        }
      }
    }
    const allPluginIds = [...pluginInits.keys()];
    const initLogger = createInitializationLogger(
      allPluginIds,
      await this.#serviceRegistry.get(backendPluginApi.coreServices.rootLogger, "root")
    );
    await Promise.all(
      allPluginIds.map(async (pluginId) => {
        await this.#serviceRegistry.initializeEagerServicesWithScope(
          "plugin",
          pluginId
        );
        const modules = moduleInits.get(pluginId);
        if (modules) {
          const tree = DependencyGraph.fromIterable(
            Array.from(modules).map(([moduleId, moduleInit]) => ({
              value: { moduleId, moduleInit },
              // Relationships are reversed at this point since we're only interested in the extension points.
              // If a modules provides extension point A we want it to be initialized AFTER all modules
              // that depend on extension point A, so that they can provide their extensions.
              consumes: Array.from(moduleInit.provides).map((p) => p.id),
              provides: Array.from(moduleInit.consumes).map((c) => c.id)
            }))
          );
          const circular = tree.detectCircularDependency();
          if (circular) {
            throw new errors.ConflictError(
              `Circular dependency detected for modules of plugin '${pluginId}', ${circular.map(({ moduleId }) => `'${moduleId}'`).join(" -> ")}`
            );
          }
          await tree.parallelTopologicalTraversal(
            async ({ moduleId, moduleInit }) => {
              const moduleDeps = await this.#getInitDeps(
                moduleInit.init.deps,
                pluginId,
                moduleId
              );
              await moduleInit.init.func(moduleDeps).catch((error) => {
                throw new errors.ForwardedError(
                  `Module '${moduleId}' for plugin '${pluginId}' startup failed`,
                  error
                );
              });
            }
          );
        }
        const pluginInit = pluginInits.get(pluginId);
        if (pluginInit) {
          const pluginDeps = await this.#getInitDeps(
            pluginInit.init.deps,
            pluginId
          );
          await pluginInit.init.func(pluginDeps).catch((error) => {
            throw new errors.ForwardedError(
              `Plugin '${pluginId}' startup failed`,
              error
            );
          });
        }
        initLogger.onPluginStarted(pluginId);
        const lifecycleService2 = await this.#getPluginLifecycleImpl(pluginId);
        await lifecycleService2.startup();
      })
    );
    const lifecycleService = await this.#getRootLifecycleImpl();
    await lifecycleService.startup();
    initLogger.onAllStarted();
    if (process.env.NODE_ENV !== "test") {
      const rootLogger = await this.#serviceRegistry.get(
        backendPluginApi.coreServices.rootLogger,
        "root"
      );
      process.on("unhandledRejection", (reason) => {
        rootLogger?.child({ type: "unhandledRejection" })?.error("Unhandled rejection", reason);
      });
      process.on("uncaughtException", (error) => {
        rootLogger?.child({ type: "uncaughtException" })?.error("Uncaught exception", error);
      });
    }
  }
  // It's fine to call .stop() multiple times, which for example can happen with manual stop + process exit
  async stop() {
    instanceRegistry.unregister(this);
    if (!this.#stopPromise) {
      this.#stopPromise = this.#doStop();
    }
    await this.#stopPromise;
  }
  async #doStop() {
    if (!this.#startPromise) {
      return;
    }
    try {
      await this.#startPromise;
    } catch (error) {
    }
    const lifecycleService = await this.#getRootLifecycleImpl();
    await lifecycleService.shutdown();
  }
  // Bit of a hacky way to grab the lifecycle services, potentially find a nicer way to do this
  async #getRootLifecycleImpl() {
    const lifecycleService = await this.#serviceRegistry.get(
      backendPluginApi.coreServices.rootLifecycle,
      "root"
    );
    const service = lifecycleService;
    if (service && typeof service.startup === "function" && typeof service.shutdown === "function") {
      return service;
    }
    throw new Error("Unexpected root lifecycle service implementation");
  }
  async #getPluginLifecycleImpl(pluginId) {
    const lifecycleService = await this.#serviceRegistry.get(
      backendPluginApi.coreServices.lifecycle,
      pluginId
    );
    const service = lifecycleService;
    if (service && typeof service.startup === "function") {
      return service;
    }
    throw new Error("Unexpected plugin lifecycle service implementation");
  }
  async #applyBackendFeatureLoaders(loaders) {
    for (const loader of loaders) {
      const deps = /* @__PURE__ */ new Map();
      const missingRefs = /* @__PURE__ */ new Set();
      for (const [name, ref] of Object.entries(loader.deps ?? {})) {
        if (ref.scope !== "root") {
          throw new Error(
            `Feature loaders can only depend on root scoped services, but '${name}' is scoped to '${ref.scope}'. Offending loader is ${loader.description}`
          );
        }
        const impl = await this.#serviceRegistry.get(
          ref,
          "root"
        );
        if (impl) {
          deps.set(name, impl);
        } else {
          missingRefs.add(ref);
        }
      }
      if (missingRefs.size > 0) {
        const missing = Array.from(missingRefs).join(", ");
        throw new Error(
          `No service available for the following ref(s): ${missing}, depended on by feature loader ${loader.description}`
        );
      }
      const result = await loader.loader(Object.fromEntries(deps)).then((features) => features.map(unwrapFeature)).catch((error) => {
        throw new errors.ForwardedError(
          `Feature loader ${loader.description} failed`,
          error
        );
      });
      let didAddServiceFactory = false;
      const newLoaders = new Array();
      for await (const feature of result) {
        if (isBackendFeatureLoader(feature)) {
          newLoaders.push(feature);
        } else {
          didAddServiceFactory ||= isServiceFactory(feature);
          this.#addFeature(feature);
        }
      }
      if (didAddServiceFactory) {
        this.#serviceRegistry.checkForCircularDeps();
      }
      if (newLoaders.length > 0) {
        await this.#applyBackendFeatureLoaders(newLoaders);
      }
    }
  }
}
function toInternalBackendFeature(feature) {
  if (feature.$$type !== "@backstage/BackendFeature") {
    throw new Error(`Invalid BackendFeature, bad type '${feature.$$type}'`);
  }
  const internal = feature;
  if (internal.version !== "v1") {
    throw new Error(
      `Invalid BackendFeature, bad version '${internal.version}'`
    );
  }
  return internal;
}
function isServiceFactory(feature) {
  const internal = toInternalBackendFeature(feature);
  if (internal.featureType === "service") {
    return true;
  }
  return "service" in internal;
}
function isBackendRegistrations(feature) {
  const internal = toInternalBackendFeature(feature);
  if (internal.featureType === "registrations") {
    return true;
  }
  return "getRegistrations" in internal;
}
function isBackendFeatureLoader(feature) {
  return toInternalBackendFeature(feature).featureType === "loader";
}

class BackstageBackend {
  #initializer;
  constructor(defaultServiceFactories) {
    this.#initializer = new BackendInitializer(defaultServiceFactories);
  }
  add(feature) {
    if (isPromise(feature)) {
      this.#initializer.add(feature.then((f) => unwrapFeature(f.default)));
    } else {
      this.#initializer.add(unwrapFeature(feature));
    }
  }
  async start() {
    await this.#initializer.start();
  }
  async stop() {
    await this.#initializer.stop();
  }
}
function isPromise(value) {
  return typeof value === "object" && value !== null && "then" in value && typeof value.then === "function";
}

function createSpecializedBackend(options) {
  const exists = /* @__PURE__ */ new Set();
  const duplicates = /* @__PURE__ */ new Set();
  for (const { service } of options.defaultServiceFactories) {
    if (exists.has(service.id)) {
      duplicates.add(service.id);
    } else {
      exists.add(service.id);
    }
  }
  if (duplicates.size > 0) {
    const ids = Array.from(duplicates).join(", ");
    throw new Error(`Duplicate service implementations provided for ${ids}`);
  }
  if (exists.has(backendPluginApi.coreServices.pluginMetadata.id)) {
    throw new Error(
      `The ${backendPluginApi.coreServices.pluginMetadata.id} service cannot be overridden`
    );
  }
  return new BackstageBackend(options.defaultServiceFactories);
}

exports.createSpecializedBackend = createSpecializedBackend;
//# sourceMappingURL=index.cjs.js.map
