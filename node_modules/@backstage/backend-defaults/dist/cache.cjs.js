'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var Keyv = require('keyv');
var crypto = require('crypto');
var types = require('@backstage/types');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Keyv__default = /*#__PURE__*/_interopDefaultCompat(Keyv);

function ttlToMilliseconds(ttl) {
  return typeof ttl === "number" ? ttl : types.durationToMilliseconds(ttl);
}

class DefaultCacheClient {
  #client;
  #clientFactory;
  #options;
  constructor(client, clientFactory, options) {
    this.#client = client;
    this.#clientFactory = clientFactory;
    this.#options = options;
  }
  async get(key) {
    const k = this.getNormalizedKey(key);
    const value = await this.#client.get(k);
    return value;
  }
  async set(key, value, opts = {}) {
    const k = this.getNormalizedKey(key);
    const ttl = opts.ttl !== void 0 ? ttlToMilliseconds(opts.ttl) : void 0;
    await this.#client.set(k, value, ttl);
  }
  async delete(key) {
    const k = this.getNormalizedKey(key);
    await this.#client.delete(k);
  }
  withOptions(options) {
    const newOptions = { ...this.#options, ...options };
    return new DefaultCacheClient(
      this.#clientFactory(newOptions),
      this.#clientFactory,
      newOptions
    );
  }
  /**
   * Ensures keys are well-formed for any/all cache stores.
   */
  getNormalizedKey(candidateKey) {
    const wellFormedKey = Buffer.from(candidateKey).toString("base64");
    if (wellFormedKey.length < 200) {
      return wellFormedKey;
    }
    return crypto.createHash("sha256").update(candidateKey).digest("base64");
  }
}

class CacheManager {
  /**
   * Keys represent supported `backend.cache.store` values, mapped to factories
   * that return Keyv instances appropriate to the store.
   */
  storeFactories = {
    redis: this.createRedisStoreFactory(),
    memcache: this.createMemcacheStoreFactory(),
    memory: this.createMemoryStoreFactory()
  };
  logger;
  store;
  connection;
  useRedisSets;
  errorHandler;
  defaultTtl;
  /**
   * Creates a new {@link CacheManager} instance by reading from the `backend`
   * config section, specifically the `.cache` key.
   *
   * @param config - The loaded application configuration.
   */
  static fromConfig(config, options = {}) {
    const store = config.getOptionalString("backend.cache.store") || "memory";
    const defaultTtlConfig = config.getOptional("backend.cache.defaultTtl");
    const connectionString = config.getOptionalString("backend.cache.connection") || "";
    const useRedisSets = config.getOptionalBoolean("backend.cache.useRedisSets") ?? true;
    const logger = options.logger?.child({
      type: "cacheManager"
    });
    let defaultTtl;
    if (defaultTtlConfig !== void 0 && defaultTtlConfig !== null) {
      if (typeof defaultTtlConfig === "number") {
        defaultTtl = defaultTtlConfig;
      } else if (typeof defaultTtlConfig === "object" && !Array.isArray(defaultTtlConfig)) {
        defaultTtl = types.durationToMilliseconds(defaultTtlConfig);
      } else {
        throw new Error(
          `Invalid configuration backend.cache.defaultTtl: ${defaultTtlConfig}, expected milliseconds number or HumanDuration object`
        );
      }
    }
    return new CacheManager(
      store,
      connectionString,
      useRedisSets,
      options.onError,
      logger,
      defaultTtl
    );
  }
  /** @internal */
  constructor(store, connectionString, useRedisSets, errorHandler, logger, defaultTtl) {
    if (!this.storeFactories.hasOwnProperty(store)) {
      throw new Error(`Unknown cache store: ${store}`);
    }
    this.logger = logger;
    this.store = store;
    this.connection = connectionString;
    this.useRedisSets = useRedisSets;
    this.errorHandler = errorHandler;
    this.defaultTtl = defaultTtl;
  }
  /**
   * Generates a PluginCacheManager for consumption by plugins.
   *
   * @param pluginId - The plugin that the cache manager should be created for.
   *        Plugin names should be unique.
   */
  forPlugin(pluginId) {
    const clientFactory = (options) => {
      const ttl = options.defaultTtl ?? this.defaultTtl;
      return this.getClientWithTtl(
        pluginId,
        ttl !== void 0 ? ttlToMilliseconds(ttl) : void 0
      );
    };
    return new DefaultCacheClient(clientFactory({}), clientFactory, {});
  }
  getClientWithTtl(pluginId, ttl) {
    return this.storeFactories[this.store](pluginId, ttl);
  }
  createRedisStoreFactory() {
    const KeyvRedis = require("@keyv/redis");
    let store;
    return (pluginId, defaultTtl) => {
      if (!store) {
        store = new KeyvRedis(this.connection, {
          useRedisSets: this.useRedisSets
        });
        store.on("error", (err) => {
          this.logger?.error("Failed to create redis cache client", err);
          this.errorHandler?.(err);
        });
      }
      return new Keyv__default.default({
        namespace: pluginId,
        ttl: defaultTtl,
        store,
        emitErrors: false,
        useRedisSets: this.useRedisSets
      });
    };
  }
  createMemcacheStoreFactory() {
    const KeyvMemcache = require("@keyv/memcache");
    let store;
    return (pluginId, defaultTtl) => {
      if (!store) {
        store = new KeyvMemcache(this.connection);
        store.on("error", (err) => {
          this.logger?.error("Failed to create memcache cache client", err);
          this.errorHandler?.(err);
        });
      }
      return new Keyv__default.default({
        namespace: pluginId,
        ttl: defaultTtl,
        emitErrors: false,
        store
      });
    };
  }
  createMemoryStoreFactory() {
    const store = /* @__PURE__ */ new Map();
    return (pluginId, defaultTtl) => new Keyv__default.default({
      namespace: pluginId,
      ttl: defaultTtl,
      emitErrors: false,
      store
    });
  }
}

const cacheServiceFactory = backendPluginApi.createServiceFactory({
  service: backendPluginApi.coreServices.cache,
  deps: {
    config: backendPluginApi.coreServices.rootConfig,
    plugin: backendPluginApi.coreServices.pluginMetadata,
    logger: backendPluginApi.coreServices.rootLogger
  },
  async createRootContext({ config, logger }) {
    return CacheManager.fromConfig(config, { logger });
  },
  async factory({ plugin }, manager) {
    return manager.forPlugin(plugin.getId());
  }
});

exports.CacheManager = CacheManager;
exports.cacheServiceFactory = cacheServiceFactory;
//# sourceMappingURL=cache.cjs.js.map
