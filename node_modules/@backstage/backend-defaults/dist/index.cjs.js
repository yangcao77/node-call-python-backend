'use strict';

var backendAppApi = require('@backstage/backend-app-api');
var auth = require('@backstage/backend-defaults/auth');
var cache = require('@backstage/backend-defaults/cache');
var database = require('@backstage/backend-defaults/database');
var discovery = require('@backstage/backend-defaults/discovery');
var httpAuth = require('@backstage/backend-defaults/httpAuth');
var httpRouter = require('@backstage/backend-defaults/httpRouter');
var lifecycle = require('@backstage/backend-defaults/lifecycle');
var logger = require('@backstage/backend-defaults/logger');
var permissions = require('@backstage/backend-defaults/permissions');
var rootConfig = require('@backstage/backend-defaults/rootConfig');
var rootHealth = require('@backstage/backend-defaults/rootHealth');
var rootHttpRouter = require('@backstage/backend-defaults/rootHttpRouter');
var rootLifecycle = require('@backstage/backend-defaults/rootLifecycle');
var rootLogger = require('@backstage/backend-defaults/rootLogger');
var scheduler = require('@backstage/backend-defaults/scheduler');
var urlReader = require('@backstage/backend-defaults/urlReader');
var userInfo = require('@backstage/backend-defaults/userInfo');
var pluginEventsNode = require('@backstage/plugin-events-node');
var backendPluginApi = require('@backstage/backend-plugin-api');
var fs = require('fs-extra');
var platformPath = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const defaultServiceFactories = [
  auth.authServiceFactory,
  cache.cacheServiceFactory,
  rootConfig.rootConfigServiceFactory,
  database.databaseServiceFactory,
  discovery.discoveryServiceFactory,
  httpAuth.httpAuthServiceFactory,
  httpRouter.httpRouterServiceFactory,
  lifecycle.lifecycleServiceFactory,
  logger.loggerServiceFactory,
  permissions.permissionsServiceFactory,
  rootHealth.rootHealthServiceFactory,
  rootHttpRouter.rootHttpRouterServiceFactory,
  rootLifecycle.rootLifecycleServiceFactory,
  rootLogger.rootLoggerServiceFactory,
  scheduler.schedulerServiceFactory,
  userInfo.userInfoServiceFactory,
  urlReader.urlReaderServiceFactory,
  pluginEventsNode.eventsServiceFactory
];
function createBackend() {
  return backendAppApi.createSpecializedBackend({ defaultServiceFactories });
}

const DETECTED_PACKAGE_ROLES = [
  "node-library",
  "backend",
  "backend-plugin",
  "backend-plugin-module"
];
function isBackendFeature(value) {
  return !!value && ["object", "function"].includes(typeof value) && value.$$type === "@backstage/BackendFeature";
}
function isBackendFeatureFactory(value) {
  return !!value && typeof value === "function" && value.$$type === "@backstage/BackendFeatureFactory";
}
async function findClosestPackageDir(searchDir) {
  let path = searchDir;
  for (let i = 0; i < 1e3; i++) {
    const packagePath = platformPath.resolve(path, "package.json");
    const exists = await fs__default.default.pathExists(packagePath);
    if (exists) {
      return path;
    }
    const newPath = platformPath.dirname(path);
    if (newPath === path) {
      return void 0;
    }
    path = newPath;
  }
  throw new Error(
    `Iteration limit reached when searching for root package.json at ${searchDir}`
  );
}
class PackageDiscoveryService {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
  }
  getDependencyNames(path) {
    const { dependencies } = require(path);
    const packagesConfig = this.config.getOptional("backend.packages");
    const dependencyNames = Object.keys(dependencies || {});
    if (packagesConfig === "all") {
      return dependencyNames;
    }
    const includedPackagesConfig = this.config.getOptionalStringArray(
      "backend.packages.include"
    );
    const includedPackages = includedPackagesConfig ? new Set(includedPackagesConfig) : dependencyNames;
    const excludedPackagesSet = new Set(
      this.config.getOptionalStringArray("backend.packages.exclude")
    );
    return [...includedPackages].filter((name) => !excludedPackagesSet.has(name));
  }
  async getBackendFeatures() {
    const packagesConfig = this.config.getOptional("backend.packages");
    if (!packagesConfig || Object.keys(packagesConfig).length === 0) {
      return { features: [] };
    }
    const packageDir = await findClosestPackageDir(process.argv[1]);
    if (!packageDir) {
      throw new Error("Package discovery failed to find package.json");
    }
    const dependencyNames = this.getDependencyNames(
      platformPath.resolve(packageDir, "package.json")
    );
    const features = [];
    for (const name of dependencyNames) {
      const depPkg = require(require.resolve(`${name}/package.json`, {
        paths: [packageDir]
      }));
      if (!depPkg?.backstage?.role || !DETECTED_PACKAGE_ROLES.includes(depPkg.backstage.role)) {
        continue;
      }
      const exportedModulePaths = [
        require.resolve(name, {
          paths: [packageDir]
        })
      ];
      try {
        exportedModulePaths.push(
          require.resolve(`${name}/alpha`, { paths: [packageDir] })
        );
      } catch {
      }
      for (const modulePath of exportedModulePaths) {
        const mod = require(modulePath);
        if (isBackendFeature(mod.default)) {
          this.logger.info(`Detected: ${name}`);
          features.push(mod.default);
        }
        if (isBackendFeatureFactory(mod.default)) {
          this.logger.info(`Detected: ${name}`);
          features.push(mod.default());
        }
      }
    }
    return { features };
  }
}

const discoveryFeatureLoader = backendPluginApi.createBackendFeatureLoader({
  deps: {
    config: backendPluginApi.coreServices.rootConfig,
    logger: backendPluginApi.coreServices.rootLogger
  },
  async loader({ config, logger }) {
    const service = new PackageDiscoveryService(config, logger);
    const { features } = await service.getBackendFeatures();
    return features;
  }
});

exports.createBackend = createBackend;
exports.discoveryFeatureLoader = discoveryFeatureLoader;
//# sourceMappingURL=index.cjs.js.map
