'use strict';

var Router = require('express-promise-router');
var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var types = require('@backstage/types');
var pathToRegexp = require('path-to-regexp');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

const DEFAULT_TIMEOUT = { seconds: 5 };
function createLifecycleMiddleware(options) {
  const { lifecycle, startupRequestPauseTimeout = DEFAULT_TIMEOUT } = options;
  let state = "init";
  const waiting = /* @__PURE__ */ new Set();
  lifecycle.addStartupHook(async () => {
    if (state === "init") {
      state = "up";
      for (const item of waiting) {
        clearTimeout(item.timeout);
        item.next();
      }
      waiting.clear();
    }
  });
  lifecycle.addShutdownHook(async () => {
    state = "down";
    for (const item of waiting) {
      clearTimeout(item.timeout);
      item.next(new errors.ServiceUnavailableError("Service is shutting down"));
    }
    waiting.clear();
  });
  const timeoutMs = types.durationToMilliseconds(startupRequestPauseTimeout);
  return (_req, _res, next) => {
    if (state === "up") {
      next();
      return;
    } else if (state === "down") {
      next(new errors.ServiceUnavailableError("Service is shutting down"));
      return;
    }
    const item = {
      next,
      timeout: setTimeout(() => {
        if (waiting.delete(item)) {
          next(new errors.ServiceUnavailableError("Service has not started up yet"));
        }
      }, timeoutMs)
    };
    waiting.add(item);
  };
}

function createPathPolicyPredicate(policyPath) {
  if (policyPath === "/" || policyPath === "*") {
    return () => true;
  }
  const pathRegex = pathToRegexp.pathToRegexp(policyPath, void 0, {
    end: false
  });
  return (path) => {
    return pathRegex.test(path);
  };
}
function createCredentialsBarrier(options) {
  const { httpAuth, config } = options;
  const disableDefaultAuthPolicy = config.getOptionalBoolean(
    "backend.auth.dangerouslyDisableDefaultAuthPolicy"
  );
  if (disableDefaultAuthPolicy) {
    return {
      middleware: (_req, _res, next) => next(),
      addAuthPolicy: () => {
      }
    };
  }
  const unauthenticatedPredicates = new Array();
  const cookiePredicates = new Array();
  const middleware = (req, _, next) => {
    const allowsUnauthenticated = unauthenticatedPredicates.some(
      (predicate) => predicate(req.path)
    );
    if (allowsUnauthenticated) {
      next();
      return;
    }
    const allowsCookie = cookiePredicates.some(
      (predicate) => predicate(req.path)
    );
    httpAuth.credentials(req, {
      allow: ["user", "service"],
      allowLimitedAccess: allowsCookie
    }).then(
      () => next(),
      (err) => next(err)
    );
  };
  const addAuthPolicy = (policy) => {
    if (policy.allow === "unauthenticated") {
      unauthenticatedPredicates.push(createPathPolicyPredicate(policy.path));
    } else if (policy.allow === "user-cookie") {
      cookiePredicates.push(createPathPolicyPredicate(policy.path));
    } else {
      throw new Error("Invalid auth policy");
    }
  };
  return { middleware, addAuthPolicy };
}

function createAuthIntegrationRouter(options) {
  const router = Router__default.default();
  router.get("/.backstage/auth/v1/jwks.json", async (_req, res) => {
    const { keys } = await options.auth.listPublicServiceKeys();
    res.json({ keys });
  });
  return router;
}

const WELL_KNOWN_COOKIE_PATH_V1 = "/.backstage/auth/v1/cookie";
function createCookieAuthRefreshMiddleware(options) {
  const { auth, httpAuth } = options;
  const router = Router__default.default();
  router.get(WELL_KNOWN_COOKIE_PATH_V1, async (_, res) => {
    const { expiresAt } = await httpAuth.issueUserCookie(res);
    res.json({ expiresAt: expiresAt.toISOString() });
  });
  router.delete(WELL_KNOWN_COOKIE_PATH_V1, async (_, res) => {
    const credentials = await auth.getNoneCredentials();
    await httpAuth.issueUserCookie(res, { credentials });
    res.status(204).end();
  });
  return router;
}

const httpRouterServiceFactory = backendPluginApi.createServiceFactory({
  service: backendPluginApi.coreServices.httpRouter,
  initialization: "always",
  deps: {
    plugin: backendPluginApi.coreServices.pluginMetadata,
    config: backendPluginApi.coreServices.rootConfig,
    lifecycle: backendPluginApi.coreServices.lifecycle,
    rootHttpRouter: backendPluginApi.coreServices.rootHttpRouter,
    auth: backendPluginApi.coreServices.auth,
    httpAuth: backendPluginApi.coreServices.httpAuth
  },
  async factory({ auth, httpAuth, config, plugin, rootHttpRouter, lifecycle }) {
    const router = Router__default.default();
    rootHttpRouter.use(`/api/${plugin.getId()}`, router);
    const credentialsBarrier = createCredentialsBarrier({
      httpAuth,
      config
    });
    router.use(createAuthIntegrationRouter({ auth }));
    router.use(createLifecycleMiddleware({ lifecycle }));
    router.use(credentialsBarrier.middleware);
    router.use(createCookieAuthRefreshMiddleware({ auth, httpAuth }));
    return {
      use(handler) {
        router.use(handler);
      },
      addAuthPolicy(policy) {
        credentialsBarrier.addAuthPolicy(policy);
      }
    };
  }
});

exports.createLifecycleMiddleware = createLifecycleMiddleware;
exports.httpRouterServiceFactory = httpRouterServiceFactory;
//# sourceMappingURL=httpRouter.cjs.js.map
