'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var config = require('@backstage/config');
var errors = require('@backstage/errors');
var knexFactory = require('knex');
var lodash = require('lodash');
var limiterFactory = require('p-limit');
var yn = require('yn');
var format = require('pg-format');
var backendDevUtils = require('@backstage/backend-dev-utils');
var fs = require('fs-extra');
var platformPath = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var knexFactory__default = /*#__PURE__*/_interopDefaultCompat(knexFactory);
var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);
var format__default = /*#__PURE__*/_interopDefaultCompat(format);
var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);

function defaultNameOverride(name) {
  return {
    connection: {
      database: name
    }
  };
}

function mergeDatabaseConfig(config, ...overrides) {
  return lodash.merge({}, config, ...overrides);
}

const ddlLimiter$1 = limiterFactory__default.default(1);
function createMysqlDatabaseClient(dbConfig, overrides) {
  const knexConfig = buildMysqlDatabaseConfig(dbConfig, overrides);
  const database = knexFactory__default.default(knexConfig);
  return database;
}
function buildMysqlDatabaseConfig(dbConfig, overrides) {
  return mergeDatabaseConfig(
    dbConfig.get(),
    {
      connection: getMysqlConnectionConfig(dbConfig, !!overrides),
      useNullAsDefault: true
    },
    overrides
  );
}
function getMysqlConnectionConfig(dbConfig, parseConnectionString) {
  const connection = dbConfig.get("connection");
  const isConnectionString = typeof connection === "string" || connection instanceof String;
  const autoParse = typeof parseConnectionString !== "boolean";
  const shouldParseConnectionString = autoParse ? isConnectionString : parseConnectionString && isConnectionString;
  return shouldParseConnectionString ? parseMysqlConnectionString(connection) : connection;
}
function parseMysqlConnectionString(connectionString) {
  try {
    const {
      protocol,
      username,
      password,
      port,
      hostname,
      pathname,
      searchParams
    } = new URL(connectionString);
    if (protocol !== "mysql:") {
      throw new Error(`Unknown protocol ${protocol}`);
    } else if (!username || !password) {
      throw new Error(`Missing username/password`);
    } else if (!pathname.match(/^\/[^/]+$/)) {
      throw new Error(`Expected single path segment`);
    }
    const result = {
      user: username,
      password,
      host: hostname,
      port: Number(port || 3306),
      database: decodeURIComponent(pathname.substring(1))
    };
    const ssl = searchParams.get("ssl");
    if (ssl) {
      result.ssl = ssl;
    }
    const debug = searchParams.get("debug");
    if (debug) {
      result.debug = yn__default.default(debug);
    }
    return result;
  } catch (e) {
    throw new errors.InputError(
      `Error while parsing MySQL connection string, ${e}`,
      e
    );
  }
}
async function ensureMysqlDatabaseExists(dbConfig, ...databases) {
  const admin = createMysqlDatabaseClient(dbConfig, {
    connection: {
      database: null
    },
    pool: {
      min: 0,
      acquireTimeoutMillis: 1e4
    }
  });
  try {
    const ensureDatabase = async (database) => {
      await admin.raw(`CREATE DATABASE IF NOT EXISTS ??`, [database]);
    };
    await Promise.all(
      databases.map(async (database) => {
        let lastErr = void 0;
        for (let i = 0; i < 3; i++) {
          try {
            return await ddlLimiter$1(() => ensureDatabase(database));
          } catch (err) {
            lastErr = err;
          }
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        throw lastErr;
      })
    );
  } finally {
    await admin.destroy();
  }
}
async function dropMysqlDatabase(dbConfig, ...databases) {
  const admin = createMysqlDatabaseClient(dbConfig, {
    connection: {
      database: null
    },
    pool: {
      min: 0,
      acquireTimeoutMillis: 1e4
    }
  });
  try {
    const dropDatabase = async (database) => {
      await admin.raw(`DROP DATABASE ??`, [database]);
    };
    await Promise.all(
      databases.map(async (database) => {
        return await ddlLimiter$1(() => dropDatabase(database));
      })
    );
  } finally {
    await admin.destroy();
  }
}
function pluginPath$3(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection$2(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parseMysqlConnectionString(connection) : connection;
}
class MysqlConnector {
  constructor(config, prefix) {
    this.config = config;
    this.prefix = prefix;
  }
  async getClient(pluginId, _deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const databaseName = this.getDatabaseName(pluginId);
    if (databaseName && this.getEnsureExistsConfig(pluginId)) {
      try {
        await ensureMysqlDatabaseExists(pluginConfig, databaseName);
      } catch (error) {
        throw new Error(
          `Failed to connect to the database to make sure that '${databaseName}' exists, ${error}`
        );
      }
    }
    const pluginDivisionMode = this.getPluginDivisionModeConfig();
    if (pluginDivisionMode !== "database") {
      throw new Error(
        `The MySQL driver does not support plugin division mode '${pluginDivisionMode}'`
      );
    }
    const databaseClientOverrides = mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId)
    );
    const client = createMysqlDatabaseClient(
      pluginConfig,
      databaseClientOverrides
    );
    return client;
  }
  async dropDatabase(...databaseNames) {
    return await dropMysqlDatabase(this.config, ...databaseNames);
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using
   * global and plugin specific database config. If no explicit database name,
   * this method will provide a generated name which is the pluginId prefixed
   * with 'backstage_plugin_'.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const databaseName = connection?.database;
    return databaseName ?? `${this.prefix}${pluginId}`;
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath$3(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath$3(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath$3(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getEnsureExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureExists") ?? true;
    return this.config.getOptionalBoolean(`${pluginPath$3(pluginId)}.ensureExists`) ?? baseConfig;
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted
   * unless `pluginDivisionMode` is set to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection$2(this.config.get("connection"));
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection$2(
      this.config.getOptional(`${pluginPath$3(pluginId)}.connection`)
    );
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`• database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? defaultNameOverride(databaseName) : {};
  }
}

function defaultSchemaOverride(name) {
  return {
    searchPath: [name]
  };
}

const ddlLimiter = limiterFactory__default.default(1);
function createPgDatabaseClient(dbConfig, overrides) {
  const knexConfig = buildPgDatabaseConfig(dbConfig, overrides);
  const database = knexFactory__default.default(knexConfig);
  const role = dbConfig.getOptionalString("role");
  if (role) {
    database.client.pool.on(
      "createSuccess",
      async (_event, pgClient) => {
        const query = format__default.default("SET ROLE %I", role);
        await pgClient.query(query);
      }
    );
  }
  return database;
}
function buildPgDatabaseConfig(dbConfig, overrides) {
  return mergeDatabaseConfig(
    dbConfig.get(),
    {
      connection: getPgConnectionConfig(dbConfig, !!overrides),
      useNullAsDefault: true
    },
    overrides
  );
}
function getPgConnectionConfig(dbConfig, parseConnectionString) {
  const connection = dbConfig.get("connection");
  const isConnectionString = typeof connection === "string" || connection instanceof String;
  const autoParse = typeof parseConnectionString !== "boolean";
  const shouldParseConnectionString = autoParse ? isConnectionString : parseConnectionString && isConnectionString;
  return shouldParseConnectionString ? parsePgConnectionString(connection) : connection;
}
function parsePgConnectionString(connectionString) {
  const parse = requirePgConnectionString();
  return parse(connectionString);
}
function requirePgConnectionString() {
  try {
    return require("pg-connection-string").parse;
  } catch (e) {
    throw new errors.ForwardedError("Postgres: Install 'pg-connection-string'", e);
  }
}
async function ensurePgDatabaseExists(dbConfig, ...databases) {
  const admin = createPgDatabaseClient(dbConfig, {
    connection: {
      database: "postgres"
    },
    pool: {
      min: 0,
      acquireTimeoutMillis: 1e4
    }
  });
  try {
    const ensureDatabase = async (database) => {
      const result = await admin.from("pg_database").where("datname", database).count();
      if (parseInt(result[0].count, 10) > 0) {
        return;
      }
      await admin.raw(`CREATE DATABASE ??`, [database]);
    };
    await Promise.all(
      databases.map(async (database) => {
        let lastErr = void 0;
        for (let i = 0; i < 3; i++) {
          try {
            return await ddlLimiter(() => ensureDatabase(database));
          } catch (err) {
            lastErr = err;
          }
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        throw lastErr;
      })
    );
  } finally {
    await admin.destroy();
  }
}
async function ensurePgSchemaExists(dbConfig, ...schemas) {
  const admin = createPgDatabaseClient(dbConfig);
  const role = dbConfig.getOptionalString("role");
  try {
    const ensureSchema = async (database) => {
      if (role) {
        await admin.raw(`CREATE SCHEMA IF NOT EXISTS ?? AUTHORIZATION ??`, [
          database,
          role
        ]);
      } else {
        await admin.raw(`CREATE SCHEMA IF NOT EXISTS ??`, [database]);
      }
    };
    await Promise.all(
      schemas.map((database) => ddlLimiter(() => ensureSchema(database)))
    );
  } finally {
    await admin.destroy();
  }
}
async function dropPgDatabase(dbConfig, ...databases) {
  const admin = createPgDatabaseClient(dbConfig);
  try {
    await Promise.all(
      databases.map(async (database) => {
        await ddlLimiter(() => admin.raw(`DROP DATABASE ??`, [database]));
      })
    );
  } finally {
    await admin.destroy();
  }
}
function pluginPath$2(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection$1(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parsePgConnectionString(connection) : connection;
}
class PgConnector {
  constructor(config, prefix) {
    this.config = config;
    this.prefix = prefix;
  }
  async getClient(pluginId, _deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const databaseName = this.getDatabaseName(pluginId);
    if (databaseName && this.getEnsureExistsConfig(pluginId)) {
      try {
        await ensurePgDatabaseExists(pluginConfig, databaseName);
      } catch (error) {
        throw new Error(
          `Failed to connect to the database to make sure that '${databaseName}' exists, ${error}`
        );
      }
    }
    let schemaOverrides;
    if (this.getPluginDivisionModeConfig() === "schema") {
      schemaOverrides = defaultSchemaOverride(pluginId);
      if (this.getEnsureSchemaExistsConfig(pluginId) || this.getEnsureExistsConfig(pluginId)) {
        try {
          await ensurePgSchemaExists(pluginConfig, pluginId);
        } catch (error) {
          throw new Error(
            `Failed to connect to the database to make sure that schema for plugin '${pluginId}' exists, ${error}`
          );
        }
      }
    }
    const databaseClientOverrides = mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId),
      schemaOverrides
    );
    const client = createPgDatabaseClient(
      pluginConfig,
      databaseClientOverrides
    );
    return client;
  }
  async dropDatabase(...databaseNames) {
    return await dropPgDatabase(this.config, ...databaseNames);
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using global
   * and plugin specific database config. If no explicit database name is configured
   * and `pluginDivisionMode` is not `schema`, this method will provide a generated name
   * which is the pluginId prefixed with 'backstage_plugin_'. If `pluginDivisionMode` is
   * `schema`, it will fallback to using the default database for the knex instance.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const databaseName = connection?.database;
    if (this.getPluginDivisionModeConfig() === "schema") {
      return databaseName;
    }
    return databaseName ?? `${this.prefix}${pluginId}`;
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath$2(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath$2(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath$2(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getEnsureExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureExists") ?? true;
    return this.config.getOptionalBoolean(`${pluginPath$2(pluginId)}.ensureExists`) ?? baseConfig;
  }
  getEnsureSchemaExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureSchemaExists") ?? false;
    return this.config.getOptionalBoolean(
      `${pluginPath$2(pluginId)}.getEnsureSchemaExistsConfig`
    ) ?? baseConfig;
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted
   * unless `pluginDivisionMode` is set to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection$1(this.config.get("connection"));
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection$1(
      this.config.getOptional(`${pluginPath$2(pluginId)}.connection`)
    );
    baseConnection.application_name ||= `backstage_plugin_${pluginId}`;
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`• database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? defaultNameOverride(databaseName) : {};
  }
}

function createSqliteDatabaseClient(dbConfig, overrides, deps) {
  const knexConfig = buildSqliteDatabaseConfig(dbConfig, overrides);
  const connConfig = knexConfig.connection;
  const filename = connConfig.filename ?? ":memory:";
  if (filename !== ":memory:") {
    const directory = platformPath__default.default.dirname(filename);
    fs.ensureDirSync(directory);
  }
  let database;
  if (deps && filename === ":memory:") {
    const devStore = backendDevUtils.DevDataStore.get();
    if (devStore) {
      const dataKey = `sqlite3-db-${deps.pluginMetadata.getId()}`;
      const connectionLoader = async () => {
        const { data: seedData } = await devStore.load(dataKey);
        return {
          ...knexConfig.connection,
          filename: seedData ?? ":memory:"
        };
      };
      database = knexFactory__default.default({
        ...knexConfig,
        connection: Object.assign(connectionLoader, {
          // This is a workaround for the knex SQLite driver always warning when using a config loader
          filename: ":memory:"
        })
      });
      deps.lifecycle.addShutdownHook(async () => {
        const connection = await database.client.acquireConnection();
        const data = connection.serialize();
        await devStore.save(dataKey, data);
      });
    } else {
      database = knexFactory__default.default(knexConfig);
    }
  } else {
    database = knexFactory__default.default(knexConfig);
  }
  database.client.pool.on("createSuccess", (_eventId, resource) => {
    resource.run("PRAGMA foreign_keys = ON", () => {
    });
  });
  return database;
}
function buildSqliteDatabaseConfig(dbConfig, overrides) {
  const baseConfig = dbConfig.get();
  if (typeof baseConfig.connection === "string") {
    baseConfig.connection = { filename: baseConfig.connection };
  }
  if (overrides && typeof overrides.connection === "string") {
    overrides.connection = { filename: overrides.connection };
  }
  const config = mergeDatabaseConfig(
    {
      connection: {}
    },
    baseConfig,
    {
      useNullAsDefault: true
    },
    overrides
  );
  return config;
}
function createSqliteNameOverride(name) {
  return {
    connection: parseSqliteConnectionString(name)
  };
}
function parseSqliteConnectionString(name) {
  return {
    filename: name
  };
}
function pluginPath$1(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parseSqliteConnectionString(connection) : connection;
}
class Sqlite3Connector {
  constructor(config) {
    this.config = config;
  }
  async getClient(pluginId, deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const pluginDivisionMode = this.getPluginDivisionModeConfig();
    if (pluginDivisionMode !== "database") {
      throw new Error(
        `The SQLite driver does not support plugin division mode '${pluginDivisionMode}'`
      );
    }
    const databaseClientOverrides = mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId)
    );
    const client = createSqliteDatabaseClient(
      pluginConfig,
      databaseClientOverrides,
      deps
    );
    return client;
  }
  async dropDatabase(..._databaseNames) {
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using global
   * and plugin specific database config. If no explicit database name is configured
   * and `pluginDivisionMode` is not `schema`, this method will provide a generated name
   * which is the pluginId prefixed with 'backstage_plugin_'. If `pluginDivisionMode` is
   * `schema`, it will fallback to using the default database for the knex instance.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const sqliteFilename = connection.filename;
    if (sqliteFilename === ":memory:") {
      return sqliteFilename;
    }
    const sqliteDirectory = connection.directory ?? ".";
    return platformPath__default.default.join(sqliteDirectory, sqliteFilename ?? `${pluginId}.sqlite`);
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath$1(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath$1(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath$1(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted for
   * all supported databases excluding SQLite unless `pluginDivisionMode` is set
   * to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { client, overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection(this.config.get("connection"));
    if (client.includes("sqlite3") && "filename" in baseConnection && baseConnection.filename !== ":memory:") {
      throw new Error(
        "`connection.filename` is not supported for the base sqlite connection. Prefer `connection.directory` or provide a filename for the plugin connection instead."
      );
    }
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection(
      this.config.getOptional(`${pluginPath$1(pluginId)}.connection`)
    );
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`• database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? createSqliteNameOverride(databaseName) : {};
  }
}

function pluginPath(pluginId) {
  return `plugin.${pluginId}`;
}
class DatabaseManagerImpl {
  constructor(config, connectors, options, databaseCache = /* @__PURE__ */ new Map()) {
    this.config = config;
    this.connectors = connectors;
    this.options = options;
    this.databaseCache = databaseCache;
  }
  /**
   * Generates a PluginDatabaseManager for consumption by plugins.
   *
   * @param pluginId - The plugin that the database manager should be created for. Plugin names
   * should be unique as they are used to look up database config overrides under
   * `backend.database.plugin`.
   */
  forPlugin(pluginId, deps) {
    const client = this.getClientType(pluginId).client;
    const connector = this.connectors[client];
    if (!connector) {
      throw new Error(
        `Unsupported database client type '${client}' specified for plugin '${pluginId}'`
      );
    }
    const getClient = () => this.getDatabase(pluginId, connector, deps);
    const migrations = { skip: false, ...this.options?.migrations };
    return { getClient, migrations };
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  /**
   * Provides a scoped Knex client for a plugin as per application config.
   *
   * @param pluginId - Plugin to get a Knex client for
   * @returns Promise which resolves to a scoped Knex database client for a
   *          plugin
   */
  async getDatabase(pluginId, connector, deps) {
    if (this.databaseCache.has(pluginId)) {
      return this.databaseCache.get(pluginId);
    }
    const clientPromise = connector.getClient(pluginId, deps);
    this.databaseCache.set(pluginId, clientPromise);
    if (process.env.NODE_ENV !== "test") {
      clientPromise.then((client) => this.startKeepaliveLoop(pluginId, client));
    }
    return clientPromise;
  }
  startKeepaliveLoop(pluginId, client) {
    let lastKeepaliveFailed = false;
    setInterval(() => {
      client?.raw("select 1").then(
        () => {
          lastKeepaliveFailed = false;
        },
        (error) => {
          if (!lastKeepaliveFailed) {
            lastKeepaliveFailed = true;
            this.options?.logger?.warn(
              `Database keepalive failed for plugin ${pluginId}, ${errors.stringifyError(
                error
              )}`
            );
          }
        }
      );
    }, 60 * 1e3);
  }
}
class DatabaseManager {
  constructor(impl) {
    this.impl = impl;
  }
  /**
   * Creates a {@link DatabaseManager} from `backend.database` config.
   *
   * @param config - The loaded application configuration.
   * @param options - An optional configuration object.
   */
  static fromConfig(config, options) {
    const databaseConfig = config.getConfig("backend.database");
    const prefix = databaseConfig.getOptionalString("prefix") || "backstage_plugin_";
    return new DatabaseManager(
      new DatabaseManagerImpl(
        databaseConfig,
        {
          pg: new PgConnector(databaseConfig, prefix),
          sqlite3: new Sqlite3Connector(databaseConfig),
          "better-sqlite3": new Sqlite3Connector(databaseConfig),
          mysql: new MysqlConnector(databaseConfig, prefix),
          mysql2: new MysqlConnector(databaseConfig, prefix)
        },
        options
      )
    );
  }
  /**
   * Generates a PluginDatabaseManager for consumption by plugins.
   *
   * @param pluginId - The plugin that the database manager should be created for. Plugin names
   * should be unique as they are used to look up database config overrides under
   * `backend.database.plugin`.
   */
  forPlugin(pluginId, deps) {
    return this.impl.forPlugin(pluginId, deps);
  }
}
async function dropDatabase(dbConfig, ...databaseNames) {
  const client = dbConfig.getString("client");
  const prefix = dbConfig.getOptionalString("prefix") || "backstage_plugin_";
  if (client === "pg") {
    await new PgConnector(dbConfig, prefix).dropDatabase(...databaseNames);
  } else if (client === "mysql" || client === "mysql2") {
    await new MysqlConnector(dbConfig, prefix).dropDatabase(...databaseNames);
  }
}

const databaseServiceFactory = backendPluginApi.createServiceFactory({
  service: backendPluginApi.coreServices.database,
  deps: {
    config: backendPluginApi.coreServices.rootConfig,
    lifecycle: backendPluginApi.coreServices.lifecycle,
    pluginMetadata: backendPluginApi.coreServices.pluginMetadata
  },
  async createRootContext({ config: config$1 }) {
    return config$1.getOptional("backend.database") ? DatabaseManager.fromConfig(config$1) : DatabaseManager.fromConfig(
      new config.ConfigReader({
        backend: {
          database: { client: "better-sqlite3", connection: ":memory:" }
        }
      })
    );
  },
  async factory({ pluginMetadata, lifecycle }, databaseManager) {
    return databaseManager.forPlugin(pluginMetadata.getId(), {
      pluginMetadata,
      lifecycle
    });
  }
});

exports.DatabaseManager = DatabaseManager;
exports.databaseServiceFactory = databaseServiceFactory;
exports.dropDatabase = dropDatabase;
//# sourceMappingURL=database.cjs.js.map
