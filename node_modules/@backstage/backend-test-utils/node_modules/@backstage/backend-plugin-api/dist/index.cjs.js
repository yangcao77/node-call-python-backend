'use strict';

var config = require('@backstage/config');
var luxon = require('luxon');
var paths = require('./cjs/paths-D7KGMZeP.cjs.js');
var cliCommon = require('@backstage/cli-common');
require('@backstage/errors');
require('path');
require('fs');

function createServiceRef(options) {
  const { id, scope = "plugin", defaultFactory } = options;
  return {
    id,
    scope,
    get T() {
      throw new Error(`tried to read ServiceRef.T of ${this}`);
    },
    toString() {
      return `serviceRef{${options.id}}`;
    },
    $$type: "@backstage/ServiceRef",
    __defaultFactory: defaultFactory
  };
}
function createServiceFactory(options) {
  const configCallback = typeof options === "function" ? options : () => options;
  const factory = (o) => {
    const anyConf = configCallback(o);
    if (anyConf.service.scope === "root") {
      const c2 = anyConf;
      return {
        $$type: "@backstage/BackendFeature",
        version: "v1",
        service: c2.service,
        initialization: c2.initialization,
        deps: c2.deps,
        factory: async (deps) => c2.factory(deps)
      };
    }
    const c = anyConf;
    return {
      $$type: "@backstage/BackendFeature",
      version: "v1",
      service: c.service,
      initialization: c.initialization,
      ..."createRootContext" in c ? {
        createRootContext: async (deps) => c?.createRootContext?.(deps)
      } : {},
      deps: c.deps,
      factory: async (deps, ctx) => c.factory(deps, ctx)
    };
  };
  return Object.assign(factory, factory(void 0));
}

exports.coreServices = void 0;
((coreServices2) => {
  coreServices2.auth = createServiceRef({
    id: "core.auth"
  });
  coreServices2.userInfo = createServiceRef({
    id: "core.userInfo"
  });
  coreServices2.cache = createServiceRef({
    id: "core.cache"
  });
  coreServices2.rootConfig = createServiceRef({ id: "core.rootConfig", scope: "root" });
  coreServices2.database = createServiceRef({ id: "core.database" });
  coreServices2.discovery = createServiceRef({ id: "core.discovery" });
  coreServices2.rootHealth = createServiceRef({ id: "core.rootHealth", scope: "root" });
  coreServices2.httpAuth = createServiceRef({ id: "core.httpAuth" });
  coreServices2.httpRouter = createServiceRef({ id: "core.httpRouter" });
  coreServices2.lifecycle = createServiceRef({ id: "core.lifecycle" });
  coreServices2.logger = createServiceRef({ id: "core.logger" });
  coreServices2.permissions = createServiceRef({ id: "core.permissions" });
  coreServices2.pluginMetadata = createServiceRef({ id: "core.pluginMetadata" });
  coreServices2.rootHttpRouter = createServiceRef({ id: "core.rootHttpRouter", scope: "root" });
  coreServices2.rootLifecycle = createServiceRef({ id: "core.rootLifecycle", scope: "root" });
  coreServices2.rootLogger = createServiceRef({ id: "core.rootLogger", scope: "root" });
  coreServices2.scheduler = createServiceRef({ id: "core.scheduler" });
  coreServices2.tokenManager = createServiceRef({ id: "core.tokenManager" });
  coreServices2.urlReader = createServiceRef({ id: "core.urlReader" });
  coreServices2.identity = createServiceRef({ id: "core.identity" });
})(exports.coreServices || (exports.coreServices = {}));

function readDuration(config$1, key) {
  if (typeof config$1.get(key) === "string") {
    const value = config$1.getString(key);
    const duration = luxon.Duration.fromISO(value);
    if (!duration.isValid) {
      throw new Error(`Invalid duration: ${value}`);
    }
    return duration.toObject();
  }
  return config.readDurationFromConfig(config$1, { key });
}
function readCronOrDuration(config, key) {
  const value = config.get(key);
  if (typeof value === "object" && value.cron) {
    return value;
  }
  return readDuration(config, key);
}
function readSchedulerServiceTaskScheduleDefinitionFromConfig(config) {
  const frequency = readCronOrDuration(config, "frequency");
  const timeout = readDuration(config, "timeout");
  const initialDelay = config.has("initialDelay") ? readDuration(config, "initialDelay") : void 0;
  const scope = config.getOptionalString("scope");
  if (scope && !["global", "local"].includes(scope)) {
    throw new Error(
      `Only "global" or "local" are allowed for TaskScheduleDefinition.scope, but got: ${scope}`
    );
  }
  return {
    frequency,
    timeout,
    initialDelay,
    scope
  };
}

function isDatabaseConflictError(e) {
  const message = e?.message;
  return typeof message === "string" && (/SQLITE_CONSTRAINT(?:_UNIQUE)?: UNIQUE/.test(message) || /UNIQUE constraint failed:/.test(message) || /unique constraint/.test(message) || /Duplicate entry/.test(message));
}

function createExtensionPoint(options) {
  return {
    id: options.id,
    get T() {
      if (process.env.NODE_ENV === "test") {
        return null;
      }
      throw new Error(`tried to read ExtensionPoint.T of ${this}`);
    },
    toString() {
      return `extensionPoint{${options.id}}`;
    },
    $$type: "@backstage/ExtensionPoint"
  };
}
function createBackendPlugin(options) {
  function getRegistrations() {
    const extensionPoints = [];
    let init = void 0;
    options.register({
      registerExtensionPoint(ext, impl) {
        if (init) {
          throw new Error("registerExtensionPoint called after registerInit");
        }
        extensionPoints.push([ext, impl]);
      },
      registerInit(regInit) {
        if (init) {
          throw new Error("registerInit must only be called once");
        }
        init = {
          deps: regInit.deps,
          func: regInit.init
        };
      }
    });
    if (!init) {
      throw new Error(
        `registerInit was not called by register in ${options.pluginId}`
      );
    }
    return [
      {
        type: "plugin",
        pluginId: options.pluginId,
        extensionPoints,
        init
      }
    ];
  }
  function backendFeatureCompatWrapper() {
    return backendFeatureCompatWrapper;
  }
  Object.assign(backendFeatureCompatWrapper, {
    $$type: "@backstage/BackendFeature",
    version: "v1",
    getRegistrations
  });
  return backendFeatureCompatWrapper;
}
function createBackendModule(options) {
  function getRegistrations() {
    const extensionPoints = [];
    let init = void 0;
    options.register({
      registerExtensionPoint(ext, impl) {
        if (init) {
          throw new Error("registerExtensionPoint called after registerInit");
        }
        extensionPoints.push([ext, impl]);
      },
      registerInit(regInit) {
        if (init) {
          throw new Error("registerInit must only be called once");
        }
        init = {
          deps: regInit.deps,
          func: regInit.init
        };
      }
    });
    if (!init) {
      throw new Error(
        `registerInit was not called by register in ${options.moduleId} module for ${options.pluginId}`
      );
    }
    return [
      {
        type: "module",
        pluginId: options.pluginId,
        moduleId: options.moduleId,
        extensionPoints,
        init
      }
    ];
  }
  function backendFeatureCompatWrapper() {
    return backendFeatureCompatWrapper;
  }
  Object.assign(backendFeatureCompatWrapper, {
    $$type: "@backstage/BackendFeature",
    version: "v1",
    getRegistrations
  });
  return backendFeatureCompatWrapper;
}

exports.packagePathMocks = paths.packagePathMocks;
exports.resolvePackagePath = paths.resolvePackagePath;
exports.resolveSafeChildPath = paths.resolveSafeChildPath;
Object.defineProperty(exports, "isChildPath", {
  enumerable: true,
  get: function () { return cliCommon.isChildPath; }
});
exports.createBackendModule = createBackendModule;
exports.createBackendPlugin = createBackendPlugin;
exports.createExtensionPoint = createExtensionPoint;
exports.createServiceFactory = createServiceFactory;
exports.createServiceRef = createServiceRef;
exports.isDatabaseConflictError = isDatabaseConflictError;
exports.readSchedulerServiceTaskScheduleDefinitionFromConfig = readSchedulerServiceTaskScheduleDefinitionFromConfig;
//# sourceMappingURL=index.cjs.js.map
